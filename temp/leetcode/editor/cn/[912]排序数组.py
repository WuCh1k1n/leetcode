# ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œè¯·ä½ å°†è¯¥æ•°ç»„å‡åºæ’åˆ—ã€‚ 
# 
#  
# 
#  
#  
# 
#  ç¤ºä¾‹ 1ï¼š 
# 
#  è¾“å…¥ï¼šnums = [5,2,3,1]
# è¾“å‡ºï¼š[1,2,3,5]
#  
# 
#  ç¤ºä¾‹ 2ï¼š 
# 
#  è¾“å…¥ï¼šnums = [5,1,1,2,0,0]
# è¾“å‡ºï¼š[0,0,1,1,2,5]
#  
# 
#  
# 
#  æç¤ºï¼š 
# 
#  
#  1 <= nums.length <= 50000 
#  -50000 <= nums[i] <= 50000 
#  
#  Related Topics æ•°ç»„ åˆ†æ²» æ¡¶æ’åº è®¡æ•°æ’åº åŸºæ•°æ’åº æ’åº å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰ å½’å¹¶æ’åº 
#  ğŸ‘ 390 ğŸ‘ 0


# leetcode submit region begin(Prohibit modification and deletion)
from typing import List


class Solution:
    def max_heapify(self, heap, root, heap_len):
        p = root
        while p * 2 + 1 < heap_len:
            l, r = p * 2 + 1, p * 2 + 2
            if heap_len <= r or heap[r] < heap[l]:
                nex = l
            else:
                nex = r
            if heap[p] < heap[nex]:
                heap[p], heap[nex] = heap[nex], heap[p]
                p = nex
            else:
                break

    def build_heap(self, heap):
        for i in range(len(heap) - 1, -1, -1):
            self.max_heapify(heap, i, len(heap))

    def heap_sort(self, nums):
        self.build_heap(nums)
        for i in range(len(nums) - 1, -1, -1):
            nums[i], nums[0] = nums[0], nums[i]
            self.max_heapify(nums, 0, i)

    def sortArray(self, nums: List[int]) -> List[int]:
        self.heap_sort(nums)
        return nums
# leetcode submit region end(Prohibit modification and deletion)


if __name__ == '__main__':
    Solution().sortArray([4, 6, 8, 5, 9])
